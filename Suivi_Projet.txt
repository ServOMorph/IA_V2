🧩 Étape 1 – Interface de base avec Ollama et Mistral via Kivy
🎯 Objectif

Créer une interface graphique simple permettant à l'utilisateur de communiquer avec un modèle Ollama local (Mistral) via une application Kivy.
🔨 Fonctionnalités réalisées

    Interface utilisateur avec :

        ✅ Zone de sortie (affichage de la conversation)

        ✅ Champ de saisie de texte

        ✅ Bouton d’envoi

    Envoi des messages à l’API locale d’Ollama (http://localhost:11434/api/chat)

    Traitement des réponses et affichage dans l’interface

    Prise en charge correcte du multithreading avec Clock.schedule_once() pour respecter les contraintes de Kivy

✅ Résultat

Tu disposes maintenant d’une fenêtre interactive qui te permet de :

    taper un prompt,

    l’envoyer à Mistral,

    afficher la réponse dans un champ de discussion.

    🧩 Étape 2 – Refactorisation du projet et amélioration de l’interface
🎯 Objectifs

    Rendre l’interface plus ergonomique pour saisir des messages multilignes.

    Structurer le code en plusieurs modules pour faciliter le développement futur.

🔧 Modifications réalisées

    ✅ Entrée clavier permet maintenant de passer à la ligne (plus d’envoi automatique).

    ✅ Ajout d’un bouton "Quitter" dans l’interface.

    ✅ Découpage du fichier principal en 4 modules :

        main.py → point d’entrée de l’application.

        interface.py → interface Kivy.

        ollama_api.py → gestion de l’appel API à Ollama.

        config.py → centralisation des paramètres.

✅ Résultat

L’application est maintenant :

    Plus confortable pour rédiger des messages lisibles.

    Mieux organisée, ce qui facilite les évolutions futures (historique, logs, etc.).

    🧩 Étape 3 – Nettoyage de la console et impressions utiles
🎯 Objectif

Réduire les messages affichés dans la console pour ne garder que les informations essentielles au développement :

    Entrées utilisateur.

    Réponses de l’IA.

    Erreurs critiques (ex. connexion à l’API).

    🧩 Étape 4 – Ajout de l’historique + correction d’un crash
🎯 Objectifs

    Enregistrer chaque échange (utilisateur / IA) dans un fichier texte.

    Corriger un crash silencieux lié à un attribut non initialisé dans un thread Kivy.

🔧 Modifications réalisées
✅ interface.py

    Initialisation de self.last_prompt pour éviter une AttributeError.

    Ajout d’un bloc try/except autour de la requête à l’API dans _query_and_display().

    Enregistrement de chaque échange dans historique.txt via enregistrer_echange().

✅ Nouveau fichier : historique.py

    Fonction simple pour enregistrer les messages dans un fichier :

    def enregistrer_echange(prompt, reponse, fichier='historique.txt'):
        with open(fichier, 'a', encoding='utf-8') as f:
            f.write(f"Utilisateur : {prompt.strip()}\\n")
            f.write(f"IA         : {reponse.strip()}\\n\\n")

✅ Résultat

    Tous les échanges sont sauvegardés dans historique.txt.

    La fenêtre ne se ferme plus de manière inattendue.

    L'application est plus robuste et traçable.



    🧩 Étape 5 – Nettoyage complet de la console + journalisation dans un fichier

🎯 Objectifs

    Supprimer tous les logs techniques de Kivy dans la console.

    Rediriger les impressions utiles (entrées utilisateur, réponses IA) vers un fichier debug.log.

    Conserver uniquement les erreurs critiques visibles dans la console.

🔧 Modifications réalisées

    Ajout d’un debug.log généré à chaque exécution.

    Suppression des logs Kivy via variables d’environnement KIVY_NO_CONSOLELOG et KIVY_NO_FILELOG.

    Remplacement de tous les print() par des appels explicites avec flush=True pour assurer l’écriture immédiate dans le fichier.

    Les erreurs critiques (Exception) restent affichées dans la console via sys.stderr.

✅ Résultat

    La console est propre (aucun [INFO], [Kivy], etc.).

    Tous les échanges utiles sont enregistrés dans debug.log.

    Les erreurs importantes sont visibles sans perturber l’utilisateur.

    🧩 Étape 6 – Refonte visuelle type "chat classique"

🎯 Objectifs

    Moderniser l’affichage des messages avec des bulles séparées.

    Rendre la conversation plus lisible et agréable (type messagerie).

    Corriger les problèmes de mise en forme et d’encombrement.

🔧 Modifications réalisées

    Refonte complète de l’interface des messages :

        Fond noir (mode sombre).

        Messages utilisateur alignés à gauche.

        Réponses IA alignées à droite.

        Bulles de couleur avec coins arrondis.

        Taille dynamique des bulles (s’adaptent parfaitement au texte).

    Mise à jour du layout pour :

        Scroll automatique vers le bas.

        Espacements harmonieux.

        Texte lisible (blanc sur fond sombre).

✅ Résultat

    L’interface est visuellement propre, ergonomique, agréable.

    Les messages sont bien différenciés.

    Plus de débordements ou d’espaces inutiles.

    🧩 Étape 7 – Uniformisation visuelle des boutons + effets de survol

🎯 Objectifs

    Harmoniser l'apparence des boutons Envoyer, Quitter et Copier.

    Supprimer les styles natifs des boutons Kivy (fond brut).

    Appliquer un fond personnalisé avec coins arrondis.

    Ajouter un effet de survol visuel (éclaircissement léger au passage de la souris).

🔧 Modifications réalisées

    Création d’une classe HoverButton :

        Hérite de Button.

        Dessine un RoundedRectangle personnalisé dans canvas.before.

        Gère dynamiquement l’effet de survol avec Window.bind(mouse_pos=...).

    Tous les boutons sont désormais des instances de HoverButton.

    Couleurs des boutons centralisées dans config.py (BUTTON_SEND_COLOR, BUTTON_QUIT_COLOR, etc.).

    Suppression des anciens background_color directs.

    Le bouton Copier est désormais cohérent visuellement avec Envoyer et Quitter.

✅ Résultat

    Interface visuellement homogène et professionnelle.

    Boutons stylisés sur mesure avec coins arrondis.

    Survol fluide qui améliore l'expérience utilisateur.


  🧩 Étape 8 – Définition d’un protocole de benchmark pour l’IA locale

🎯 Objectif

Élaborer un protocole de test complet et reproductible pour évaluer les performances de l’IA Mistral exécutée localement via Ollama, avec ou sans interface Kivy.

🔧 Travail réalisé

✅ Création du fichier protocole_test_IA.txt contenant les éléments suivants :

    Objectifs clairs (temps de réponse, robustesse, qualité, limites).

    Structure de fichiers dédiée (questions_IA.txt, test_performance.py, etc.).

    Déroulé détaillé de 5 types de tests :

        Temps de réponse

        Qualité des réponses

        Robustesse face aux entrées problématiques

        Limites intellectuelles et créatives du modèle

        Génération automatique d’un rapport synthétique

✅ Génération du fichier questions_IA.txt :

    Prompts classés par catégorie : simples, complexes, longs, piégeux, logiques/creatifs.

    Format prêt à être utilisé à la fois manuellement et automatiquement.

📁 Fichiers produits

    Test_IA/protocole_test_IA.txt

    Test_IA/questions_IA.txt

✅ Résultat

Le protocole de benchmark est prêt à être lancé à tout moment, de manière :

    manuelle (via l’interface Kivy pour inspection directe des réponses),

    ou automatisée (via un futur script test_performance.py en Python).

Cette base permettra d’évaluer objectivement la qualité et la robustesse du modèle local Mistral dans le cadre du projet.  



🧩 Étape 9 – Ajustement visuel des bulles et du bouton "Quitter"

🎯 Objectifs

    Uniformiser et moderniser l'apparence des bulles de conversation.

    Harmoniser le bouton "Quitter" avec le style général.

    Corriger l'attribution incorrecte des couleurs entre utilisateur et IA.

🔧 Modifications réalisées

    🎨 Refonte de la palette de couleurs :

        Bulle utilisateur : fond #292930 → (0.16, 0.16, 0.19, 1)

        Bulle IA : fond #1f3454 → (0.12, 0.20, 0.33, 1)

        ✅ Mise à jour des constantes BUBBLE_USER_COLOR et BUBBLE_IA_COLOR dans config.py.

    🧠 Correction de la logique dans la classe Bubble :

        Utilisation correcte du booléen is_user pour déterminer la couleur de la bulle.

        Suppression de la détection par texte (startswith("Utilisateur")), non fiable.

    🔘 Amélioration du bouton "Quitter" :

        Calcul automatique de la largeur exacte du texte via CoreLabel.

        Ajustement de la taille pour que le fond épouse parfaitement le mot.

        Couleur alignée avec la bulle utilisateur.

✅ Résultat

    Interface visuellement harmonieuse, sobre et cohérente.

    Les bulles sont désormais bien différenciées, avec un fond élégant.

    Le bouton "Quitter" est discret, lisible et cohérent avec l'identité visuelle.